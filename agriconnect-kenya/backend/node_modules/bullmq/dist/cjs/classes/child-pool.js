"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChildPool = void 0;
<<<<<<< HEAD
const child_process_1 = require("child_process");
const path = require("path");
const lodash_1 = require("lodash");
const process_utils_1 = require("./process-utils");
const interfaces_1 = require("../interfaces");
const utils_1 = require("../utils");
const CHILD_KILL_TIMEOUT = 30000;
const convertExecArgv = async (execArgv) => {
    const standard = [];
    const convertedArgs = [];
    for (let i = 0; i < execArgv.length; i++) {
        const arg = execArgv[i];
        if (arg.indexOf('--inspect') === -1) {
            standard.push(arg);
        }
        else {
            const argName = arg.split('=')[0];
            const port = await (await Promise.resolve().then(() => require('get-port'))).default();
            convertedArgs.push(`${argName}=${port}`);
        }
    }
    return standard.concat(convertedArgs);
};
/**
 * @see https://nodejs.org/api/process.html#process_exit_codes
 */
const exitCodesErrors = {
    1: 'Uncaught Fatal Exception',
    2: 'Unused',
    3: 'Internal JavaScript Parse Error',
    4: 'Internal JavaScript Evaluation Failure',
    5: 'Fatal Error',
    6: 'Non-function Internal Exception Handler',
    7: 'Internal Exception Handler Run-Time Failure',
    8: 'Unused',
    9: 'Invalid Argument',
    10: 'Internal JavaScript Run-Time Failure',
    12: 'Invalid Debug Argument',
    13: 'Unfinished Top-Level Await',
};
async function initChild(child, processFile) {
    const onComplete = new Promise((resolve, reject) => {
        const onMessageHandler = (msg) => {
            if (msg.cmd === interfaces_1.ParentCommand.InitCompleted) {
                resolve();
            }
            else if (msg.cmd === interfaces_1.ParentCommand.InitFailed) {
                const err = new Error();
                err.stack = msg.err.stack;
                err.message = msg.err.message;
                reject(err);
            }
            child.off('message', onMessageHandler);
            child.off('close', onCloseHandler);
        };
        const onCloseHandler = (code, signal) => {
            if (code > 128) {
                code -= 128;
            }
            const msg = exitCodesErrors[code] || `Unknown exit code ${code}`;
            reject(new Error(`Error initializing child: ${msg} and signal ${signal}`));
            child.off('message', onMessageHandler);
            child.off('close', onCloseHandler);
        };
        child.on('message', onMessageHandler);
        child.on('close', onCloseHandler);
    });
    await (0, utils_1.parentSend)(child, { cmd: interfaces_1.ChildCommand.Init, value: processFile });
    await onComplete;
}
class ChildPool {
    constructor(masterFile = path.join(process.cwd(), 'dist/cjs/classes/master.js')) {
        this.masterFile = masterFile;
        this.retained = {};
        this.free = {};
    }
    async retain(processFile) {
        const _this = this;
        let child = _this.getFree(processFile).pop();
        if (child) {
            _this.retained[child.pid] = child;
            return child;
        }
        const execArgv = await convertExecArgv(process.execArgv);
        child = (0, child_process_1.fork)(this.masterFile, [], { execArgv, stdio: 'pipe' });
        child.processFile = processFile;
        _this.retained[child.pid] = child;
        child.on('exit', _this.remove.bind(_this, child));
        child.stdout.pipe(process.stdout);
        child.stderr.pipe(process.stderr);
        await initChild(child, child.processFile);
        return child;
=======
const path = require("path");
const child_1 = require("./child");
const CHILD_KILL_TIMEOUT = 30000;
const supportCJS = () => {
    return (typeof require === 'function' &&
        typeof module === 'object' &&
        typeof module.exports === 'object');
};
class ChildPool {
    constructor({ mainFile = supportCJS()
        ? path.join(process.cwd(), 'dist/cjs/classes/main.js')
        : path.join(process.cwd(), 'dist/esm/classes/main.js'), useWorkerThreads, workerForkOptions, workerThreadsOptions, }) {
        this.retained = {};
        this.free = {};
        this.opts = {
            mainFile,
            useWorkerThreads,
            workerForkOptions,
            workerThreadsOptions,
        };
    }
    async retain(processFile) {
        let child = this.getFree(processFile).pop();
        if (child) {
            this.retained[child.pid] = child;
            return child;
        }
        child = new child_1.Child(this.opts.mainFile, processFile, {
            useWorkerThreads: this.opts.useWorkerThreads,
            workerForkOptions: this.opts.workerForkOptions,
            workerThreadsOptions: this.opts.workerThreadsOptions,
        });
        child.on('exit', this.remove.bind(this, child));
        try {
            await child.init();
            // Check status here as well, in case the child exited before we could
            // retain it.
            if (child.exitCode !== null || child.signalCode !== null) {
                throw new Error('Child exited before it could be retained');
            }
            this.retained[child.pid] = child;
            return child;
        }
        catch (err) {
            console.error(err);
            this.release(child);
            throw err;
        }
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
    }
    release(child) {
        delete this.retained[child.pid];
        this.getFree(child.processFile).push(child);
    }
    remove(child) {
        delete this.retained[child.pid];
        const free = this.getFree(child.processFile);
        const childIndex = free.indexOf(child);
        if (childIndex > -1) {
            free.splice(childIndex, 1);
        }
    }
    async kill(child, signal = 'SIGKILL') {
        this.remove(child);
<<<<<<< HEAD
        await (0, process_utils_1.killAsync)(child, signal, CHILD_KILL_TIMEOUT);
=======
        return child.kill(signal, CHILD_KILL_TIMEOUT);
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
    }
    async clean() {
        const children = Object.values(this.retained).concat(this.getAllFree());
        this.retained = {};
        this.free = {};
        await Promise.all(children.map(c => this.kill(c, 'SIGTERM')));
    }
    getFree(id) {
        return (this.free[id] = this.free[id] || []);
    }
    getAllFree() {
<<<<<<< HEAD
        return (0, lodash_1.flatten)(Object.values(this.free));
=======
        return Object.values(this.free).reduce((first, second) => first.concat(second), []);
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
    }
}
exports.ChildPool = ChildPool;
//# sourceMappingURL=child-pool.js.map