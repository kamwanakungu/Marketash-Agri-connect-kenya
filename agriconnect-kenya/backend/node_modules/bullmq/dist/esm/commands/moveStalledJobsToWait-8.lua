--[[
  Move stalled jobs to wait.

    Input:
      KEYS[1] 'stalled' (SET)
      KEYS[2] 'wait',   (LIST)
      KEYS[3] 'active', (LIST)
<<<<<<< HEAD
      KEYS[4] 'failed', (ZSET)
      KEYS[5] 'stalled-check', (KEY)
      KEYS[6] 'meta', (KEY)
      KEYS[7] 'paused', (LIST)
=======
      KEYS[4] 'stalled-check', (KEY)
      KEYS[5] 'meta', (KEY)
      KEYS[6] 'paused', (LIST)
      KEYS[7] 'marker'
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
      KEYS[8] 'event stream' (STREAM)

      ARGV[1]  Max stalled job count
      ARGV[2]  queue.toKey('')
      ARGV[3]  timestamp
      ARGV[4]  max check time

    Events:
      'stalled' with stalled job id.
]]
local rcall = redis.call

-- Includes
<<<<<<< HEAD
--- @include "includes/batches"
--- @include "includes/getTargetQueueList"
--- @include "includes/removeJob"
--- @include "includes/removeJobsByMaxAge"
--- @include "includes/removeJobsByMaxCount"
--- @include "includes/trimEvents"

-- Check if we need to check for stalled jobs now.
if rcall("EXISTS", KEYS[5]) == 1 then return {{}, {}} end

rcall("SET", KEYS[5], ARGV[3], "PX", ARGV[4])

-- Trim events before emiting them to avoid trimming events emitted in this script
trimEvents(KEYS[6], KEYS[8])

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', KEYS[1])
local stalled = {}
local failed = {}
if (#stalling > 0) then
    rcall('DEL', KEYS[1])

    local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])

    -- Remove from active list
    for i, jobId in ipairs(stalling) do
        local jobKey = ARGV[2] .. jobId

        -- Check that the lock is also missing, then we can handle this job as really stalled.
        if (rcall("EXISTS", jobKey .. ":lock") == 0) then
            --  Remove from the active queue.
            local removed = rcall("LREM", KEYS[3], 1, jobId)

            if (removed > 0) then
                -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
                local stalledCount = rcall("HINCRBY", jobKey, "stalledCounter",
                                           1)
                if (stalledCount > MAX_STALLED_JOB_COUNT) then
                  local rawOpts = rcall("HGET",jobKey, "opts")
                  local opts = cjson.decode(rawOpts)
                  local removeOnFailType = type(opts["removeOnFail"])
                  rcall("ZADD", KEYS[4], ARGV[3], jobId)
                  local failedReason = "job stalled more than allowable limit" 
                  rcall("HMSET", jobKey, "failedReason",
                        failedReason, "finishedOn", ARGV[3])
                  rcall("XADD", KEYS[8], "*", "event", "failed", "jobId",
                        jobId, 'prev', 'active', 'failedReason',
                        failedReason)

                  if removeOnFailType == "number" then
                    removeJobsByMaxCount(opts["removeOnFail"], KEYS[4], ARGV[2])
                  elseif removeOnFailType == "boolean" then
                    if opts["removeOnFail"] then
                      removeJob(jobId, false, ARGV[2])
                      rcall("ZREM", KEYS[4], jobId)
                    end
                  elseif removeOnFailType ~= "nil" then
                    local maxAge = opts["removeOnFail"]["age"]
                    local maxCount = opts["removeOnFail"]["count"]

                    if maxAge ~= nil then
                      removeJobsByMaxAge(ARGV[3], maxAge, KEYS[4], ARGV[2])
                    end

                    if maxCount ~= nil and maxCount > 0 then
                      removeJobsByMaxCount(maxCount, KEYS[4], ARGV[2])
                    end
                  end

                  table.insert(failed, jobId)                    
                else
                  local target = getTargetQueueList(KEYS[6], KEYS[2], KEYS[7])

                  -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.
                  rcall("RPUSH", target, jobId)
                  rcall("XADD", KEYS[8], "*", "event", "waiting", "jobId",
                        jobId, 'prev', 'active')

                  -- Emit the stalled event
                  rcall("XADD", KEYS[8], "*", "event", "stalled", "jobId",
                        jobId)
                  table.insert(stalled, jobId)
=======
--- @include "includes/addJobInTargetList"
--- @include "includes/batches"
--- @include "includes/moveJobToWait"
--- @include "includes/trimEvents"

local stalledKey = KEYS[1]
local waitKey = KEYS[2]
local activeKey = KEYS[3]
local stalledCheckKey = KEYS[4]
local metaKey = KEYS[5]
local pausedKey = KEYS[6]
local markerKey = KEYS[7]
local eventStreamKey = KEYS[8]
local maxStalledJobCount = tonumber(ARGV[1])
local queueKeyPrefix = ARGV[2]
local timestamp = ARGV[3]
local maxCheckTime = ARGV[4]

if rcall("EXISTS", stalledCheckKey) == 1 then
    return {}
end

rcall("SET", stalledCheckKey, timestamp, "PX", maxCheckTime)

-- Trim events before emiting them to avoid trimming events emitted in this script
trimEvents(metaKey, eventStreamKey)

-- Move all stalled jobs to wait
local stalling = rcall('SMEMBERS', stalledKey)
local stalled = {}
if (#stalling > 0) then
    rcall('DEL', stalledKey)

    -- Remove from active list
    for i, jobId in ipairs(stalling) do
        -- Markers in waitlist DEPRECATED in v5: Remove in v6.
        if string.sub(jobId, 1, 2) == "0:" then
            -- If the jobId is a delay marker ID we just remove it.
            rcall("LREM", activeKey, 1, jobId)
        else
            local jobKey = queueKeyPrefix .. jobId

            -- Check that the lock is also missing, then we can handle this job as really stalled.
            if (rcall("EXISTS", jobKey .. ":lock") == 0) then
                --  Remove from the active queue.
                local removed = rcall("LREM", activeKey, 1, jobId)

                if (removed > 0) then
                    -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.
                    local stalledCount = rcall("HINCRBY", jobKey, "stc", 1)
                    
                    -- Check if this is a repeatable job by looking at job options
                    local jobOpts = rcall("HGET", jobKey, "opts")
                    local isRepeatableJob = false
                    if jobOpts then
                        local opts = cjson.decode(jobOpts)
                        if opts and opts["repeat"] then
                            isRepeatableJob = true
                        end
                    end
                    
                    -- Only fail job if it exceeds stall limit AND is not a repeatable job
                    if stalledCount > maxStalledJobCount and not isRepeatableJob then
                        local failedReason = "job stalled more than allowable limit"
                        rcall("HSET", jobKey, "defa", failedReason)
                    end
                    
                    moveJobToWait(metaKey, activeKey, waitKey, pausedKey, markerKey, eventStreamKey, jobId,
                        "RPUSH")

                    -- Emit the stalled event
                    rcall("XADD", eventStreamKey, "*", "event", "stalled", "jobId", jobId)
                    table.insert(stalled, jobId)
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
                end
            end
        end
    end
end

-- Mark potentially stalled jobs
<<<<<<< HEAD
local active = rcall('LRANGE', KEYS[3], 0, -1)

if (#active > 0) then
  for from, to in batches(#active, 7000) do
    rcall('SADD', KEYS[1], unpack(active, from, to))
  end
end

return {failed, stalled}
=======
local active = rcall('LRANGE', activeKey, 0, -1)

if (#active > 0) then
    for from, to in batches(#active, 7000) do
        rcall('SADD', stalledKey, unpack(active, from, to))
    end
end

return stalled
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
