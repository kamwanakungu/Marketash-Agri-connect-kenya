"use strict";
<<<<<<< HEAD
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _RedisClient_instances, _a, _RedisClient_options, _RedisClient_socket, _RedisClient_queue, _RedisClient_isolationPool, _RedisClient_v4, _RedisClient_selectedDB, _RedisClient_initiateOptions, _RedisClient_initiateQueue, _RedisClient_initiateSocket, _RedisClient_initiateIsolationPool, _RedisClient_legacyMode, _RedisClient_legacySendCommand, _RedisClient_defineLegacyCommand, _RedisClient_pingTimer, _RedisClient_setPingTimer, _RedisClient_sendCommand, _RedisClient_pubSubCommand, _RedisClient_tick, _RedisClient_addMultiCommands, _RedisClient_destroyIsolationPool;
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = require("./commands");
const socket_1 = require("./socket");
const commands_queue_1 = require("./commands-queue");
const multi_command_1 = require("./multi-command");
const events_1 = require("events");
const command_options_1 = require("../command-options");
const commander_1 = require("../commander");
const generic_pool_1 = require("generic-pool");
const errors_1 = require("../errors");
const url_1 = require("url");
const pub_sub_1 = require("./pub-sub");
const package_json_1 = require("../../package.json");
class RedisClient extends events_1.EventEmitter {
    static commandOptions(options) {
        return (0, command_options_1.commandOptions)(options);
    }
    static extend(extensions) {
        const Client = (0, commander_1.attachExtensions)({
            BaseClass: _a,
            modulesExecutor: _a.prototype.commandsExecutor,
            modules: extensions?.modules,
            functionsExecutor: _a.prototype.functionsExecuter,
            functions: extensions?.functions,
            scriptsExecutor: _a.prototype.scriptsExecuter,
            scripts: extensions?.scripts
        });
        if (Client !== _a) {
            Client.prototype.Multi = multi_command_1.default.extend(extensions);
        }
        return Client;
    }
    static create(options) {
        return new (_a.extend(options))(options);
    }
    static parseURL(url) {
        // https://www.iana.org/assignments/uri-schemes/prov/redis
        const { hostname, port, protocol, username, password, pathname } = new url_1.URL(url), parsed = {
            socket: {
                host: hostname
            }
        };
        if (protocol === 'rediss:') {
            parsed.socket.tls = true;
        }
        else if (protocol !== 'redis:') {
            throw new TypeError('Invalid protocol');
        }
=======
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = __importDefault(require("../commands"));
const socket_1 = __importDefault(require("./socket"));
const authx_1 = require("../authx");
const commands_queue_1 = __importDefault(require("./commands-queue"));
const node_events_1 = require("node:events");
const commander_1 = require("../commander");
const errors_1 = require("../errors");
const node_url_1 = require("node:url");
const pub_sub_1 = require("./pub-sub");
const multi_command_1 = __importDefault(require("./multi-command"));
const HELLO_1 = __importDefault(require("../commands/HELLO"));
const legacy_mode_1 = require("./legacy-mode");
const pool_1 = require("./pool");
const generic_transformers_1 = require("../commands/generic-transformers");
const cache_1 = require("./cache");
const parser_1 = require("./parser");
const single_entry_cache_1 = __importDefault(require("../single-entry-cache"));
const package_json_1 = require("../../package.json");
const enterprise_maintenance_manager_1 = __importDefault(require("./enterprise-maintenance-manager"));
;
class RedisClient extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function (...args) {
            const parser = new parser_1.BasicCommandParser();
            command.parseCommand(parser, ...args);
            return this._self._executeCommand(command, parser, this._commandOptions, transformReply);
        };
    }
    static #createModuleCommand(command, resp) {
        const transformReply = (0, commander_1.getTransformReply)(command, resp);
        return async function (...args) {
            const parser = new parser_1.BasicCommandParser();
            command.parseCommand(parser, ...args);
            return this._self._executeCommand(command, parser, this._self._commandOptions, transformReply);
        };
    }
    static #createFunctionCommand(name, fn, resp) {
        const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
        const transformReply = (0, commander_1.getTransformReply)(fn, resp);
        return async function (...args) {
            const parser = new parser_1.BasicCommandParser();
            parser.push(...prefix);
            fn.parseCommand(parser, ...args);
            return this._self._executeCommand(fn, parser, this._self._commandOptions, transformReply);
        };
    }
    static #createScriptCommand(script, resp) {
        const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
        const transformReply = (0, commander_1.getTransformReply)(script, resp);
        return async function (...args) {
            const parser = new parser_1.BasicCommandParser();
            parser.push(...prefix);
            script.parseCommand(parser, ...args);
            return this._executeScript(script, parser, this._commandOptions, transformReply);
        };
    }
    static #SingleEntryCache = new single_entry_cache_1.default();
    static factory(config) {
        let Client = _a.#SingleEntryCache.get(config);
        if (!Client) {
            Client = (0, commander_1.attachConfig)({
                BaseClass: _a,
                commands: commands_1.default,
                createCommand: _a.#createCommand,
                createModuleCommand: _a.#createModuleCommand,
                createFunctionCommand: _a.#createFunctionCommand,
                createScriptCommand: _a.#createScriptCommand,
                config
            });
            Client.prototype.Multi = multi_command_1.default.extend(config);
            _a.#SingleEntryCache.set(config, Client);
        }
        return (options) => {
            // returning a "proxy" to prevent the namespaces._self to leak between "proxies"
            return Object.create(new Client(options));
        };
    }
    static create(options) {
        return _a.factory(options)(options);
    }
    static parseOptions(options) {
        if (options?.url) {
            const parsed = _a.parseURL(options.url);
            if (options.socket) {
                if (options.socket.tls !== undefined && options.socket.tls !== parsed.socket.tls) {
                    throw new TypeError(`tls socket option is set to ${options.socket.tls} which is mismatch with protocol or the URL ${options.url} passed`);
                }
                parsed.socket = Object.assign(options.socket, parsed.socket);
            }
            Object.assign(options, parsed);
        }
        return options;
    }
    static parseURL(url) {
        // https://www.iana.org/assignments/uri-schemes/prov/redis
        const { hostname, port, protocol, username, password, pathname } = new node_url_1.URL(url), parsed = {
            socket: {
                host: hostname,
                tls: false
            }
        };
        if (protocol !== 'redis:' && protocol !== 'rediss:') {
            throw new TypeError('Invalid protocol');
        }
        parsed.socket.tls = protocol === 'rediss:';
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
        if (port) {
            parsed.socket.port = Number(port);
        }
        if (username) {
            parsed.username = decodeURIComponent(username);
        }
        if (password) {
            parsed.password = decodeURIComponent(password);
        }
<<<<<<< HEAD
=======
        if (username || password) {
            parsed.credentialsProvider = {
                type: 'async-credentials-provider',
                credentials: async () => ({
                    username: username ? decodeURIComponent(username) : undefined,
                    password: password ? decodeURIComponent(password) : undefined
                })
            };
        }
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
        if (pathname.length > 1) {
            const database = Number(pathname.substring(1));
            if (isNaN(database)) {
                throw new TypeError('Invalid pathname');
            }
            parsed.database = database;
        }
        return parsed;
    }
<<<<<<< HEAD
    get options() {
        return __classPrivateFieldGet(this, _RedisClient_options, "f");
    }
    get isOpen() {
        return __classPrivateFieldGet(this, _RedisClient_socket, "f").isOpen;
    }
    get isReady() {
        return __classPrivateFieldGet(this, _RedisClient_socket, "f").isReady;
    }
    get isPubSubActive() {
        return __classPrivateFieldGet(this, _RedisClient_queue, "f").isPubSubActive;
    }
    get v4() {
        if (!__classPrivateFieldGet(this, _RedisClient_options, "f")?.legacyMode) {
            throw new Error('the client is not in "legacy mode"');
        }
        return __classPrivateFieldGet(this, _RedisClient_v4, "f");
    }
    constructor(options) {
        super();
        _RedisClient_instances.add(this);
        Object.defineProperty(this, "commandOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _a.commandOptions
        });
        _RedisClient_options.set(this, void 0);
        _RedisClient_socket.set(this, void 0);
        _RedisClient_queue.set(this, void 0);
        _RedisClient_isolationPool.set(this, void 0);
        _RedisClient_v4.set(this, {});
        _RedisClient_selectedDB.set(this, 0);
        _RedisClient_pingTimer.set(this, void 0);
        Object.defineProperty(this, "select", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.SELECT
        });
        Object.defineProperty(this, "subscribe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.SUBSCRIBE
        });
        Object.defineProperty(this, "unsubscribe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.UNSUBSCRIBE
        });
        Object.defineProperty(this, "pSubscribe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.PSUBSCRIBE
        });
        Object.defineProperty(this, "pUnsubscribe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.PUNSUBSCRIBE
        });
        Object.defineProperty(this, "sSubscribe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.SSUBSCRIBE
        });
        Object.defineProperty(this, "sUnsubscribe", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.SUNSUBSCRIBE
        });
        Object.defineProperty(this, "quit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.QUIT
        });
        Object.defineProperty(this, "multi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.MULTI
        });
        __classPrivateFieldSet(this, _RedisClient_options, __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateOptions).call(this, options), "f");
        __classPrivateFieldSet(this, _RedisClient_queue, __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateQueue).call(this), "f");
        __classPrivateFieldSet(this, _RedisClient_socket, __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateSocket).call(this), "f");
        // should be initiated in connect, not here
        // TODO: consider breaking in v5
        __classPrivateFieldSet(this, _RedisClient_isolationPool, __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateIsolationPool).call(this), "f");
        __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_legacyMode).call(this);
    }
    duplicate(overrides) {
        return new (Object.getPrototypeOf(this).constructor)({
            ...__classPrivateFieldGet(this, _RedisClient_options, "f"),
=======
    #options;
    #socket;
    #queue;
    #selectedDB = 0;
    #monitorCallback;
    _self = this;
    _commandOptions;
    // flag used to annotate that the client
    // was in a watch transaction when
    // a topology change occured
    #dirtyWatch;
    #watchEpoch;
    #clientSideCache;
    #credentialsSubscription = null;
    // Flag used to pause writing to the socket during maintenance windows.
    // When true, prevents new commands from being written while waiting for:
    // 1. New socket to be ready after maintenance redirect
    // 2. In-flight commands on the old socket to complete
    #paused = false;
    get clientSideCache() {
        return this._self.#clientSideCache;
    }
    get options() {
        return this._self.#options;
    }
    get isOpen() {
        return this._self.#socket.isOpen;
    }
    get isReady() {
        return this._self.#socket.isReady;
    }
    get isPubSubActive() {
        return this._self.#queue.isPubSubActive;
    }
    get socketEpoch() {
        return this._self.#socket.socketEpoch;
    }
    get isWatching() {
        return this._self.#watchEpoch !== undefined;
    }
    /**
     * Indicates whether the client's WATCH command has been invalidated by a topology change.
     * When this returns true, any transaction using WATCH will fail with a WatchError.
     * @returns true if the watched keys have been modified, false otherwise
     */
    get isDirtyWatch() {
        return this._self.#dirtyWatch !== undefined;
    }
    /**
     * Marks the client's WATCH command as invalidated due to a topology change.
     * This will cause any subsequent EXEC in a transaction to fail with a WatchError.
     * @param msg - The error message explaining why the WATCH is dirty
     */
    setDirtyWatch(msg) {
        this._self.#dirtyWatch = msg;
    }
    constructor(options) {
        super();
        this.#validateOptions(options);
        this.#options = this.#initiateOptions(options);
        this.#queue = this.#initiateQueue();
        this.#socket = this.#initiateSocket();
        if (this.#options.maintNotifications !== 'disabled') {
            new enterprise_maintenance_manager_1.default(this.#queue, this, this.#options);
        }
        ;
        if (this.#options.clientSideCache) {
            if (this.#options.clientSideCache instanceof cache_1.ClientSideCacheProvider) {
                this.#clientSideCache = this.#options.clientSideCache;
            }
            else {
                const cscConfig = this.#options.clientSideCache;
                this.#clientSideCache = new cache_1.BasicClientSideCache(cscConfig);
            }
            this.#queue.addPushHandler((push) => {
                if (push[0].toString() !== 'invalidate')
                    return false;
                if (push[1] !== null) {
                    for (const key of push[1]) {
                        this.#clientSideCache?.invalidate(key);
                    }
                }
                else {
                    this.#clientSideCache?.invalidate(null);
                }
                return true;
            });
        }
        else if (options?.emitInvalidate) {
            this.#queue.addPushHandler((push) => {
                if (push[0].toString() !== 'invalidate')
                    return false;
                if (push[1] !== null) {
                    for (const key of push[1]) {
                        this.emit('invalidate', key);
                    }
                }
                else {
                    this.emit('invalidate', null);
                }
                return true;
            });
        }
    }
    #validateOptions(options) {
        if (options?.clientSideCache && options?.RESP !== 3) {
            throw new Error('Client Side Caching is only supported with RESP3');
        }
        if (options?.emitInvalidate && options?.RESP !== 3) {
            throw new Error('emitInvalidate is only supported with RESP3');
        }
        if (options?.clientSideCache && options?.emitInvalidate) {
            throw new Error('emitInvalidate is not supported (or necessary) when clientSideCache is enabled');
        }
        if (options?.maintNotifications && options?.maintNotifications !== 'disabled' && options?.RESP !== 3) {
            throw new Error('Graceful Maintenance is only supported with RESP3');
        }
    }
    #initiateOptions(options = {}) {
        // Convert username/password to credentialsProvider if no credentialsProvider is already in place
        if (!options.credentialsProvider && (options.username || options.password)) {
            options.credentialsProvider = {
                type: 'async-credentials-provider',
                credentials: async () => ({
                    username: options.username,
                    password: options.password
                })
            };
        }
        if (options.database) {
            this._self.#selectedDB = options.database;
        }
        if (options.commandOptions) {
            this._commandOptions = options.commandOptions;
        }
        if (options.maintNotifications !== 'disabled') {
            enterprise_maintenance_manager_1.default.setupDefaultMaintOptions(options);
        }
        if (options.url) {
            const parsedOptions = _a.parseOptions(options);
            if (parsedOptions?.database) {
                this._self.#selectedDB = parsedOptions.database;
            }
            return parsedOptions;
        }
        return options;
    }
    #initiateQueue() {
        return new commands_queue_1.default(this.#options.RESP ?? 2, this.#options.commandsQueueMaxLength, (channel, listeners) => this.emit('sharded-channel-moved', channel, listeners));
    }
    /**
     * @param credentials
     */
    reAuthenticate = async (credentials) => {
        // Re-authentication is not supported on RESP2 with PubSub active
        if (!(this.isPubSubActive && !this.#options.RESP)) {
            await this.sendCommand((0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                username: credentials.username,
                password: credentials.password ?? ''
            }));
        }
    };
    #subscribeForStreamingCredentials(cp) {
        return cp.subscribe({
            onNext: credentials => {
                this.reAuthenticate(credentials).catch(error => {
                    const errorMessage = error instanceof Error ? error.message : String(error);
                    cp.onReAuthenticationError(new authx_1.CredentialsError(errorMessage));
                });
            },
            onError: (e) => {
                const errorMessage = `Error from streaming credentials provider: ${e.message}`;
                cp.onReAuthenticationError(new authx_1.UnableToObtainNewCredentialsError(errorMessage));
            }
        });
    }
    async #handshake(chainId, asap) {
        const promises = [];
        const commandsWithErrorHandlers = await this.#getHandshakeCommands();
        if (asap)
            commandsWithErrorHandlers.reverse();
        for (const { cmd, errorHandler } of commandsWithErrorHandlers) {
            promises.push(this.#queue
                .addCommand(cmd, {
                chainId,
                asap
            })
                .catch(errorHandler));
        }
        return promises;
    }
    async #getHandshakeCommands() {
        const commands = [];
        const cp = this.#options.credentialsProvider;
        if (this.#options.RESP) {
            const hello = {};
            if (cp && cp.type === 'async-credentials-provider') {
                const credentials = await cp.credentials();
                if (credentials.password) {
                    hello.AUTH = {
                        username: credentials.username ?? 'default',
                        password: credentials.password
                    };
                }
            }
            if (cp && cp.type === 'streaming-credentials-provider') {
                const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
                this.#credentialsSubscription = disposable;
                if (credentials.password) {
                    hello.AUTH = {
                        username: credentials.username ?? 'default',
                        password: credentials.password
                    };
                }
            }
            if (this.#options.name) {
                hello.SETNAME = this.#options.name;
            }
            commands.push({ cmd: (0, generic_transformers_1.parseArgs)(HELLO_1.default, this.#options.RESP, hello) });
        }
        else {
            if (cp && cp.type === 'async-credentials-provider') {
                const credentials = await cp.credentials();
                if (credentials.username || credentials.password) {
                    commands.push({
                        cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                            username: credentials.username,
                            password: credentials.password ?? ''
                        })
                    });
                }
            }
            if (cp && cp.type === 'streaming-credentials-provider') {
                const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
                this.#credentialsSubscription = disposable;
                if (credentials.username || credentials.password) {
                    commands.push({
                        cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                            username: credentials.username,
                            password: credentials.password ?? ''
                        })
                    });
                }
            }
            if (this.#options.name) {
                commands.push({
                    cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.CLIENT_SETNAME, this.#options.name)
                });
            }
        }
        if (this.#selectedDB !== 0) {
            commands.push({ cmd: ['SELECT', this.#selectedDB.toString()] });
        }
        if (this.#options.readonly) {
            commands.push({ cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.READONLY) });
        }
        if (!this.#options.disableClientInfo) {
            commands.push({
                cmd: ['CLIENT', 'SETINFO', 'LIB-VER', package_json_1.version],
                errorHandler: () => {
                    // Client libraries are expected to pipeline this command
                    // after authentication on all connections and ignore failures
                    // since they could be connected to an older version that doesn't support them.
                }
            });
            commands.push({
                cmd: [
                    'CLIENT',
                    'SETINFO',
                    'LIB-NAME',
                    this.#options.clientInfoTag
                        ? `node-redis(${this.#options.clientInfoTag})`
                        : 'node-redis'
                ],
                errorHandler: () => {
                    // Client libraries are expected to pipeline this command
                    // after authentication on all connections and ignore failures
                    // since they could be connected to an older version that doesn't support them.
                }
            });
        }
        if (this.#clientSideCache) {
            commands.push({ cmd: this.#clientSideCache.trackingOn() });
        }
        if (this.#options?.emitInvalidate) {
            commands.push({ cmd: ['CLIENT', 'TRACKING', 'ON'] });
        }
        const maintenanceHandshakeCmd = await enterprise_maintenance_manager_1.default.getHandshakeCommand(this.#options);
        if (maintenanceHandshakeCmd) {
            commands.push(maintenanceHandshakeCmd);
        }
        ;
        return commands;
    }
    #attachListeners(socket) {
        socket.on('data', chunk => {
            try {
                this.#queue.decoder.write(chunk);
            }
            catch (err) {
                this.#queue.resetDecoder();
                this.emit('error', err);
            }
        })
            .on('error', err => {
            this.emit('error', err);
            this.#clientSideCache?.onError();
            if (this.#socket.isOpen && !this.#options.disableOfflineQueue) {
                this.#queue.flushWaitingForReply(err);
            }
            else {
                this.#queue.flushAll(err);
            }
        })
            .on('connect', () => this.emit('connect'))
            .on('ready', () => {
            this.emit('ready');
            this.#setPingTimer();
            this.#maybeScheduleWrite();
        })
            .on('reconnecting', () => this.emit('reconnecting'))
            .on('drain', () => this.#maybeScheduleWrite())
            .on('end', () => this.emit('end'));
    }
    #initiateSocket() {
        const socketInitiator = async () => {
            const promises = [], chainId = Symbol('Socket Initiator');
            const resubscribePromise = this.#queue.resubscribe(chainId);
            resubscribePromise?.catch(error => {
                if (error.message && error.message.startsWith('MOVED')) {
                    this.emit('__MOVED', this._self.#queue.removeAllPubSubListeners());
                }
            });
            if (resubscribePromise) {
                promises.push(resubscribePromise);
            }
            if (this.#monitorCallback) {
                promises.push(this.#queue.monitor(this.#monitorCallback, {
                    typeMapping: this._commandOptions?.typeMapping,
                    chainId,
                    asap: true
                }));
            }
            promises.push(...(await this.#handshake(chainId, true)));
            if (promises.length) {
                this.#write();
                return Promise.all(promises);
            }
        };
        const socket = new socket_1.default(socketInitiator, this.#options.socket);
        this.#attachListeners(socket);
        return socket;
    }
    #pingTimer;
    #setPingTimer() {
        if (!this.#options.pingInterval || !this.#socket.isReady)
            return;
        clearTimeout(this.#pingTimer);
        this.#pingTimer = setTimeout(() => {
            if (!this.#socket.isReady)
                return;
            this.sendCommand(['PING'])
                .then(reply => this.emit('ping-interval', reply))
                .catch(err => this.emit('error', err))
                .finally(() => this.#setPingTimer());
        }, this.#options.pingInterval);
    }
    withCommandOptions(options) {
        const proxy = Object.create(this._self);
        proxy._commandOptions = options;
        return proxy;
    }
    _commandOptionsProxy(key, value) {
        const proxy = Object.create(this._self);
        proxy._commandOptions = Object.create(this._commandOptions ?? null);
        proxy._commandOptions[key] = value;
        return proxy;
    }
    /**
     * Override the `typeMapping` command option
     */
    withTypeMapping(typeMapping) {
        return this._commandOptionsProxy('typeMapping', typeMapping);
    }
    /**
     * Override the `abortSignal` command option
     */
    withAbortSignal(abortSignal) {
        return this._commandOptionsProxy('abortSignal', abortSignal);
    }
    /**
     * Override the `asap` command option to `true`
     */
    asap() {
        return this._commandOptionsProxy('asap', true);
    }
    /**
     * Create the "legacy" (v3/callback) interface
     */
    legacy() {
        return new legacy_mode_1.RedisLegacyClient(this);
    }
    /**
     * Create {@link RedisClientPool `RedisClientPool`} using this client as a prototype
     */
    createPool(options) {
        return pool_1.RedisClientPool.create(this._self.#options, options);
    }
    duplicate(overrides) {
        return new (Object.getPrototypeOf(this).constructor)({
            ...this._self.#options,
            commandOptions: this._commandOptions,
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
            ...overrides
        });
    }
    async connect() {
<<<<<<< HEAD
        // see comment in constructor
        __classPrivateFieldSet(this, _RedisClient_isolationPool, __classPrivateFieldGet(this, _RedisClient_isolationPool, "f") ?? __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateIsolationPool).call(this), "f");
        await __classPrivateFieldGet(this, _RedisClient_socket, "f").connect();
        return this;
    }
    async commandsExecutor(command, args) {
        const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(command, args);
        return (0, commander_1.transformCommandReply)(command, await __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, redisArgs, options), redisArgs.preserve);
    }
    sendCommand(args, options) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, args, options);
    }
    async functionsExecuter(fn, args, name) {
        const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(fn, args);
        return (0, commander_1.transformCommandReply)(fn, await this.executeFunction(name, fn, redisArgs, options), redisArgs.preserve);
    }
    executeFunction(name, fn, args, options) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, (0, commander_1.fCallArguments)(name, fn, args), options);
    }
    async scriptsExecuter(script, args) {
        const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(script, args);
        return (0, commander_1.transformCommandReply)(script, await this.executeScript(script, redisArgs, options), redisArgs.preserve);
    }
    async executeScript(script, args, options) {
        const redisArgs = ['EVALSHA', script.SHA1];
        if (script.NUMBER_OF_KEYS !== undefined) {
            redisArgs.push(script.NUMBER_OF_KEYS.toString());
        }
        redisArgs.push(...args);
        try {
            return await __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, redisArgs, options);
        }
        catch (err) {
            if (!err?.message?.startsWith?.('NOSCRIPT')) {
                throw err;
            }
            redisArgs[0] = 'EVAL';
            redisArgs[1] = script.SCRIPT;
            return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, redisArgs, options);
        }
    }
    async SELECT(options, db) {
        if (!(0, command_options_1.isCommandOptions)(options)) {
            db = options;
            options = null;
        }
        await __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, ['SELECT', db.toString()], options);
        __classPrivateFieldSet(this, _RedisClient_selectedDB, db, "f");
    }
    SUBSCRIBE(channels, listener, bufferMode) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").subscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    UNSUBSCRIBE(channels, listener, bufferMode) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").unsubscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    PSUBSCRIBE(patterns, listener, bufferMode) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").subscribe(pub_sub_1.PubSubType.PATTERNS, patterns, listener, bufferMode));
    }
    PUNSUBSCRIBE(patterns, listener, bufferMode) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").unsubscribe(pub_sub_1.PubSubType.PATTERNS, patterns, listener, bufferMode));
    }
    SSUBSCRIBE(channels, listener, bufferMode) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").subscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    SUNSUBSCRIBE(channels, listener, bufferMode) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").unsubscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    getPubSubListeners(type) {
        return __classPrivateFieldGet(this, _RedisClient_queue, "f").getPubSubListeners(type);
    }
    extendPubSubChannelListeners(type, channel, listeners) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").extendPubSubChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").extendPubSubListeners(type, listeners));
    }
    QUIT() {
        return __classPrivateFieldGet(this, _RedisClient_socket, "f").quit(async () => {
            if (__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"))
                clearTimeout(__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"));
            const quitPromise = __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(['QUIT']);
            __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
            const [reply] = await Promise.all([
                quitPromise,
                __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_destroyIsolationPool).call(this)
            ]);
            return reply;
        });
    }
    executeIsolated(fn) {
        if (!__classPrivateFieldGet(this, _RedisClient_isolationPool, "f"))
            return Promise.reject(new errors_1.ClientClosedError());
        return __classPrivateFieldGet(this, _RedisClient_isolationPool, "f").use(fn);
    }
    MULTI() {
        return new this.Multi(this.multiExecutor.bind(this), __classPrivateFieldGet(this, _RedisClient_options, "f")?.legacyMode);
    }
    async multiExecutor(commands, selectedDB, chainId) {
        if (!__classPrivateFieldGet(this, _RedisClient_socket, "f").isOpen) {
            return Promise.reject(new errors_1.ClientClosedError());
        }
        const promise = chainId ?
            // if `chainId` has a value, it's a `MULTI` (and not "pipeline") - need to add the `MULTI` and `EXEC` commands
            Promise.all([
                __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(['MULTI'], { chainId }),
                __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_addMultiCommands).call(this, commands, chainId),
                __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(['EXEC'], { chainId })
            ]) :
            __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_addMultiCommands).call(this, commands);
        __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
        const results = await promise;
        if (selectedDB !== undefined) {
            __classPrivateFieldSet(this, _RedisClient_selectedDB, selectedDB, "f");
        }
        return results;
    }
    async *scanIterator(options) {
        let cursor = 0;
        do {
            const reply = await this.scan(cursor, options);
            cursor = reply.cursor;
            for (const key of reply.keys) {
                yield key;
            }
        } while (cursor !== 0);
    }
    async *hScanIterator(key, options) {
        let cursor = 0;
        do {
            const reply = await this.hScan(key, cursor, options);
            cursor = reply.cursor;
            for (const tuple of reply.tuples) {
                yield tuple;
            }
        } while (cursor !== 0);
    }
    async *hScanNoValuesIterator(key, options) {
        let cursor = 0;
        do {
            const reply = await this.hScanNoValues(key, cursor, options);
            cursor = reply.cursor;
            for (const k of reply.keys) {
                yield k;
            }
        } while (cursor !== 0);
    }
    async *sScanIterator(key, options) {
        let cursor = 0;
        do {
            const reply = await this.sScan(key, cursor, options);
            cursor = reply.cursor;
            for (const member of reply.members) {
                yield member;
            }
        } while (cursor !== 0);
    }
    async *zScanIterator(key, options) {
        let cursor = 0;
        do {
            const reply = await this.zScan(key, cursor, options);
            cursor = reply.cursor;
            for (const member of reply.members) {
                yield member;
            }
        } while (cursor !== 0);
    }
    async disconnect() {
        if (__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"))
            clearTimeout(__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"));
        __classPrivateFieldGet(this, _RedisClient_queue, "f").flushAll(new errors_1.DisconnectsClientError());
        __classPrivateFieldGet(this, _RedisClient_socket, "f").disconnect();
        await __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_destroyIsolationPool).call(this);
    }
    ref() {
        __classPrivateFieldGet(this, _RedisClient_socket, "f").ref();
    }
    unref() {
        __classPrivateFieldGet(this, _RedisClient_socket, "f").unref();
    }
}
_a = RedisClient, _RedisClient_options = new WeakMap(), _RedisClient_socket = new WeakMap(), _RedisClient_queue = new WeakMap(), _RedisClient_isolationPool = new WeakMap(), _RedisClient_v4 = new WeakMap(), _RedisClient_selectedDB = new WeakMap(), _RedisClient_pingTimer = new WeakMap(), _RedisClient_instances = new WeakSet(), _RedisClient_initiateOptions = function _RedisClient_initiateOptions(options) {
    if (options?.url) {
        const parsed = _a.parseURL(options.url);
        if (options.socket) {
            parsed.socket = Object.assign(options.socket, parsed.socket);
        }
        Object.assign(options, parsed);
    }
    if (options?.database) {
        __classPrivateFieldSet(this, _RedisClient_selectedDB, options.database, "f");
    }
    return options;
}, _RedisClient_initiateQueue = function _RedisClient_initiateQueue() {
    return new commands_queue_1.default(__classPrivateFieldGet(this, _RedisClient_options, "f")?.commandsQueueMaxLength, (channel, listeners) => this.emit('sharded-channel-moved', channel, listeners));
}, _RedisClient_initiateSocket = function _RedisClient_initiateSocket() {
    const socketInitiator = async () => {
        const promises = [];
        if (__classPrivateFieldGet(this, _RedisClient_selectedDB, "f") !== 0) {
            promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(['SELECT', __classPrivateFieldGet(this, _RedisClient_selectedDB, "f").toString()], { asap: true }));
        }
        if (__classPrivateFieldGet(this, _RedisClient_options, "f")?.readonly) {
            promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(commands_1.default.READONLY.transformArguments(), { asap: true }));
        }
        if (!__classPrivateFieldGet(this, _RedisClient_options, "f")?.disableClientInfo) {
            promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(['CLIENT', 'SETINFO', 'LIB-VER', package_json_1.version], { asap: true }).catch(err => {
                if (!(err instanceof errors_1.ErrorReply)) {
                    throw err;
                }
            }));
            promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand([
                'CLIENT', 'SETINFO', 'LIB-NAME',
                __classPrivateFieldGet(this, _RedisClient_options, "f")?.clientInfoTag ? `node-redis(${__classPrivateFieldGet(this, _RedisClient_options, "f").clientInfoTag})` : 'node-redis'
            ], { asap: true }).catch(err => {
                if (!(err instanceof errors_1.ErrorReply)) {
                    throw err;
                }
            }));
        }
        if (__classPrivateFieldGet(this, _RedisClient_options, "f")?.name) {
            promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(commands_1.default.CLIENT_SETNAME.transformArguments(__classPrivateFieldGet(this, _RedisClient_options, "f").name), { asap: true }));
        }
        if (__classPrivateFieldGet(this, _RedisClient_options, "f")?.username || __classPrivateFieldGet(this, _RedisClient_options, "f")?.password) {
            promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(commands_1.default.AUTH.transformArguments({
                username: __classPrivateFieldGet(this, _RedisClient_options, "f").username,
                password: __classPrivateFieldGet(this, _RedisClient_options, "f").password ?? ''
            }), { asap: true }));
        }
        const resubscribePromise = __classPrivateFieldGet(this, _RedisClient_queue, "f").resubscribe();
        if (resubscribePromise) {
            promises.push(resubscribePromise);
        }
        if (promises.length) {
            __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this, true);
            await Promise.all(promises);
        }
    };
    return new socket_1.default(socketInitiator, __classPrivateFieldGet(this, _RedisClient_options, "f")?.socket)
        .on('data', chunk => __classPrivateFieldGet(this, _RedisClient_queue, "f").onReplyChunk(chunk))
        .on('error', err => {
        this.emit('error', err);
        if (__classPrivateFieldGet(this, _RedisClient_socket, "f").isOpen && !__classPrivateFieldGet(this, _RedisClient_options, "f")?.disableOfflineQueue) {
            __classPrivateFieldGet(this, _RedisClient_queue, "f").flushWaitingForReply(err);
        }
        else {
            __classPrivateFieldGet(this, _RedisClient_queue, "f").flushAll(err);
        }
    })
        .on('connect', () => {
        this.emit('connect');
    })
        .on('ready', () => {
        this.emit('ready');
        __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_setPingTimer).call(this);
        __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
    })
        .on('reconnecting', () => this.emit('reconnecting'))
        .on('drain', () => __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this))
        .on('end', () => this.emit('end'));
}, _RedisClient_initiateIsolationPool = function _RedisClient_initiateIsolationPool() {
    return (0, generic_pool_1.createPool)({
        create: async () => {
            const duplicate = this.duplicate({
                isolationPoolOptions: undefined
            }).on('error', err => this.emit('error', err));
            await duplicate.connect();
            return duplicate;
        },
        destroy: client => client.disconnect()
    }, __classPrivateFieldGet(this, _RedisClient_options, "f")?.isolationPoolOptions);
}, _RedisClient_legacyMode = function _RedisClient_legacyMode() {
    var _b, _c;
    if (!__classPrivateFieldGet(this, _RedisClient_options, "f")?.legacyMode)
        return;
    __classPrivateFieldGet(this, _RedisClient_v4, "f").sendCommand = __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).bind(this);
    this.sendCommand = (...args) => {
        const result = __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_legacySendCommand).call(this, ...args);
        if (result) {
            result.promise
                .then(reply => result.callback(null, reply))
                .catch(err => result.callback(err));
        }
    };
    for (const [name, command] of Object.entries(commands_1.default)) {
        __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, name, command);
        (_b = this)[_c = name.toLowerCase()] ?? (_b[_c] = this[name]);
    }
    // hard coded commands
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'SELECT');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'select');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'SUBSCRIBE');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'subscribe');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'PSUBSCRIBE');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'pSubscribe');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'UNSUBSCRIBE');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'unsubscribe');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'PUNSUBSCRIBE');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'pUnsubscribe');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'QUIT');
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, 'quit');
}, _RedisClient_legacySendCommand = function _RedisClient_legacySendCommand(...args) {
    const callback = typeof args[args.length - 1] === 'function' ?
        args.pop() :
        undefined;
    const promise = __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, (0, commander_1.transformLegacyCommandArguments)(args));
    if (callback)
        return {
            promise,
            callback
        };
    promise.catch(err => this.emit('error', err));
}, _RedisClient_defineLegacyCommand = function _RedisClient_defineLegacyCommand(name, command) {
    __classPrivateFieldGet(this, _RedisClient_v4, "f")[name] = this[name].bind(this);
    this[name] = command && command.TRANSFORM_LEGACY_REPLY && command.transformReply ?
        (...args) => {
            const result = __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_legacySendCommand).call(this, name, ...args);
            if (result) {
                result.promise
                    .then(reply => result.callback(null, command.transformReply(reply)))
                    .catch(err => result.callback(err));
            }
        } :
        (...args) => this.sendCommand(name, ...args);
}, _RedisClient_setPingTimer = function _RedisClient_setPingTimer() {
    if (!__classPrivateFieldGet(this, _RedisClient_options, "f")?.pingInterval || !__classPrivateFieldGet(this, _RedisClient_socket, "f").isReady)
        return;
    clearTimeout(__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"));
    __classPrivateFieldSet(this, _RedisClient_pingTimer, setTimeout(() => {
        if (!__classPrivateFieldGet(this, _RedisClient_socket, "f").isReady)
            return;
        // using #sendCommand to support legacy mode
        __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, ['PING'])
            .then(reply => this.emit('ping-interval', reply))
            .catch(err => this.emit('error', err))
            .finally(() => __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_setPingTimer).call(this));
    }, __classPrivateFieldGet(this, _RedisClient_options, "f").pingInterval), "f");
}, _RedisClient_sendCommand = function _RedisClient_sendCommand(args, options) {
    if (!__classPrivateFieldGet(this, _RedisClient_socket, "f").isOpen) {
        return Promise.reject(new errors_1.ClientClosedError());
    }
    else if (options?.isolated) {
        return this.executeIsolated(isolatedClient => isolatedClient.sendCommand(args, {
            ...options,
            isolated: false
        }));
    }
    else if (!__classPrivateFieldGet(this, _RedisClient_socket, "f").isReady && __classPrivateFieldGet(this, _RedisClient_options, "f")?.disableOfflineQueue) {
        return Promise.reject(new errors_1.ClientOfflineError());
    }
    const promise = __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(args, options);
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
    return promise;
}, _RedisClient_pubSubCommand = function _RedisClient_pubSubCommand(promise) {
    if (promise === undefined)
        return Promise.resolve();
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
    return promise;
}, _RedisClient_tick = function _RedisClient_tick(force = false) {
    if (__classPrivateFieldGet(this, _RedisClient_socket, "f").writableNeedDrain || (!force && !__classPrivateFieldGet(this, _RedisClient_socket, "f").isReady)) {
        return;
    }
    __classPrivateFieldGet(this, _RedisClient_socket, "f").cork();
    while (!__classPrivateFieldGet(this, _RedisClient_socket, "f").writableNeedDrain) {
        const args = __classPrivateFieldGet(this, _RedisClient_queue, "f").getCommandToSend();
        if (args === undefined)
            break;
        __classPrivateFieldGet(this, _RedisClient_socket, "f").writeCommand(args);
    }
}, _RedisClient_addMultiCommands = function _RedisClient_addMultiCommands(commands, chainId) {
    return Promise.all(commands.map(({ args }) => __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(args, { chainId })));
}, _RedisClient_destroyIsolationPool = async function _RedisClient_destroyIsolationPool() {
    await __classPrivateFieldGet(this, _RedisClient_isolationPool, "f").drain();
    await __classPrivateFieldGet(this, _RedisClient_isolationPool, "f").clear();
    __classPrivateFieldSet(this, _RedisClient_isolationPool, undefined, "f");
};
exports.default = RedisClient;
(0, commander_1.attachCommands)({
    BaseClass: RedisClient,
    commands: commands_1.default,
    executor: RedisClient.prototype.commandsExecutor
});
RedisClient.prototype.Multi = multi_command_1.default;
=======
        await this._self.#socket.connect();
        return this;
    }
    /**
     * @internal
     */
    _ejectSocket() {
        const socket = this._self.#socket;
        // @ts-ignore
        this._self.#socket = null;
        socket.removeAllListeners();
        return socket;
    }
    /**
     * @internal
     */
    _insertSocket(socket) {
        if (this._self.#socket) {
            this._self._ejectSocket().destroy();
        }
        this._self.#socket = socket;
        this._self.#attachListeners(this._self.#socket);
    }
    /**
     * @internal
     */
    _maintenanceUpdate(update) {
        this._self.#socket.setMaintenanceTimeout(update.relaxedSocketTimeout);
        this._self.#queue.setMaintenanceCommandTimeout(update.relaxedCommandTimeout);
    }
    /**
     * @internal
     */
    _pause() {
        this._self.#paused = true;
    }
    /**
     * @internal
     */
    _unpause() {
        this._self.#paused = false;
        this._self.#maybeScheduleWrite();
    }
    /**
     * @internal
     */
    async _executeCommand(command, parser, commandOptions, transformReply) {
        const csc = this._self.#clientSideCache;
        const defaultTypeMapping = this._self.#options.commandOptions === commandOptions;
        const fn = () => { return this.sendCommand(parser.redisArgs, commandOptions); };
        if (csc && command.CACHEABLE && defaultTypeMapping) {
            return await csc.handleCache(this._self, parser, fn, transformReply, commandOptions?.typeMapping);
        }
        else {
            const reply = await fn();
            if (transformReply) {
                return transformReply(reply, parser.preserve, commandOptions?.typeMapping);
            }
            return reply;
        }
    }
    /**
     * @internal
     */
    async _executeScript(script, parser, options, transformReply) {
        const args = parser.redisArgs;
        let reply;
        try {
            reply = await this.sendCommand(args, options);
        }
        catch (err) {
            if (!err?.message?.startsWith?.('NOSCRIPT'))
                throw err;
            args[0] = 'EVAL';
            args[1] = script.SCRIPT;
            reply = await this.sendCommand(args, options);
        }
        return transformReply ?
            transformReply(reply, parser.preserve, options?.typeMapping) :
            reply;
    }
    sendCommand(args, options) {
        if (!this._self.#socket.isOpen) {
            return Promise.reject(new errors_1.ClientClosedError());
        }
        else if (!this._self.#socket.isReady && this._self.#options.disableOfflineQueue) {
            return Promise.reject(new errors_1.ClientOfflineError());
        }
        // Merge global options with provided options
        const opts = {
            ...this._self._commandOptions,
            ...options
        };
        const promise = this._self.#queue.addCommand(args, opts);
        this._self.#scheduleWrite();
        return promise;
    }
    async SELECT(db) {
        await this.sendCommand(['SELECT', db.toString()]);
        this._self.#selectedDB = db;
    }
    select = this.SELECT;
    #pubSubCommand(promise) {
        if (promise === undefined)
            return Promise.resolve();
        this.#scheduleWrite();
        return promise;
    }
    SUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
    }
    subscribe = this.SUBSCRIBE;
    UNSUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    PSUBSCRIBE(patterns, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
    }
    pSubscribe = this.PSUBSCRIBE;
    PUNSUBSCRIBE(patterns, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    SSUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
        return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    async WATCH(key) {
        const reply = await this._self.sendCommand((0, generic_transformers_1.pushVariadicArguments)(['WATCH'], key));
        this._self.#watchEpoch ??= this._self.socketEpoch;
        return reply;
    }
    watch = this.WATCH;
    async UNWATCH() {
        const reply = await this._self.sendCommand(['UNWATCH']);
        this._self.#watchEpoch = undefined;
        return reply;
    }
    unwatch = this.UNWATCH;
    getPubSubListeners(type) {
        return this._self.#queue.getPubSubListeners(type);
    }
    extendPubSubChannelListeners(type, channel, listeners) {
        return this._self.#pubSubCommand(this._self.#queue.extendPubSubChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
        return this._self.#pubSubCommand(this._self.#queue.extendPubSubListeners(type, listeners));
    }
    #write() {
        if (this.#paused) {
            return;
        }
        this.#socket.write(this.#queue.commandsToWrite());
    }
    #scheduledWrite;
    #scheduleWrite() {
        if (!this.#socket.isReady || this.#scheduledWrite)
            return;
        this.#scheduledWrite = setImmediate(() => {
            this.#write();
            this.#scheduledWrite = undefined;
        });
    }
    #maybeScheduleWrite() {
        if (!this.#queue.isWaitingToWrite())
            return;
        this.#scheduleWrite();
    }
    /**
     * @internal
     */
    async _executePipeline(commands, selectedDB) {
        if (!this._self.#socket.isOpen) {
            return Promise.reject(new errors_1.ClientClosedError());
        }
        const chainId = Symbol('Pipeline Chain'), promise = Promise.all(commands.map(({ args }) => this._self.#queue.addCommand(args, {
            chainId,
            typeMapping: this._commandOptions?.typeMapping
        })));
        this._self.#scheduleWrite();
        const result = await promise;
        if (selectedDB !== undefined) {
            this._self.#selectedDB = selectedDB;
        }
        return result;
    }
    /**
     * @internal
     */
    async _executeMulti(commands, selectedDB) {
        const dirtyWatch = this._self.#dirtyWatch;
        this._self.#dirtyWatch = undefined;
        const watchEpoch = this._self.#watchEpoch;
        this._self.#watchEpoch = undefined;
        if (!this._self.#socket.isOpen) {
            throw new errors_1.ClientClosedError();
        }
        if (dirtyWatch) {
            throw new errors_1.WatchError(dirtyWatch);
        }
        if (watchEpoch && watchEpoch !== this._self.socketEpoch) {
            throw new errors_1.WatchError('Client reconnected after WATCH');
        }
        const typeMapping = this._commandOptions?.typeMapping;
        const chainId = Symbol('MULTI Chain');
        const promises = [
            this._self.#queue.addCommand(['MULTI'], { chainId }),
        ];
        for (const { args } of commands) {
            promises.push(this._self.#queue.addCommand(args, {
                chainId,
                typeMapping
            }));
        }
        promises.push(this._self.#queue.addCommand(['EXEC'], { chainId }));
        this._self.#scheduleWrite();
        const results = await Promise.all(promises), execResult = results[results.length - 1];
        if (execResult === null) {
            throw new errors_1.WatchError();
        }
        if (selectedDB !== undefined) {
            this._self.#selectedDB = selectedDB;
        }
        return execResult;
    }
    MULTI() {
        return new this.Multi(this._executeMulti.bind(this), this._executePipeline.bind(this), this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async *scanIterator(options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.scan(cursor, options);
            cursor = reply.cursor;
            yield reply.keys;
        } while (cursor !== '0');
    }
    async *hScanIterator(key, options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.hScan(key, cursor, options);
            cursor = reply.cursor;
            yield reply.entries;
        } while (cursor !== '0');
    }
    async *hScanValuesIterator(key, options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.hScanNoValues(key, cursor, options);
            cursor = reply.cursor;
            yield reply.fields;
        } while (cursor !== '0');
    }
    async *hScanNoValuesIterator(key, options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.hScanNoValues(key, cursor, options);
            cursor = reply.cursor;
            yield reply.fields;
        } while (cursor !== '0');
    }
    async *sScanIterator(key, options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.sScan(key, cursor, options);
            cursor = reply.cursor;
            yield reply.members;
        } while (cursor !== '0');
    }
    async *zScanIterator(key, options) {
        let cursor = options?.cursor ?? '0';
        do {
            const reply = await this.zScan(key, cursor, options);
            cursor = reply.cursor;
            yield reply.members;
        } while (cursor !== '0');
    }
    async MONITOR(callback) {
        const promise = this._self.#queue.monitor(callback, {
            typeMapping: this._commandOptions?.typeMapping
        });
        this._self.#scheduleWrite();
        await promise;
        this._self.#monitorCallback = callback;
    }
    monitor = this.MONITOR;
    /**
     * Reset the client to its default state (i.e. stop PubSub, stop monitoring, select default DB, etc.)
     */
    async reset() {
        const chainId = Symbol('Reset Chain'), promises = [this._self.#queue.reset(chainId)], selectedDB = this._self.#options?.database ?? 0;
        this._self.#credentialsSubscription?.dispose();
        this._self.#credentialsSubscription = null;
        promises.push(...(await this._self.#handshake(chainId, false)));
        this._self.#scheduleWrite();
        await Promise.all(promises);
        this._self.#selectedDB = selectedDB;
        this._self.#monitorCallback = undefined;
        this._self.#dirtyWatch = undefined;
        this._self.#watchEpoch = undefined;
    }
    /**
     * If the client has state, reset it.
     * An internal function to be used by wrapper class such as `RedisClientPool`.
     * @internal
     */
    resetIfDirty() {
        let shouldReset = false;
        if (this._self.#selectedDB !== (this._self.#options?.database ?? 0)) {
            console.warn('Returning a client with a different selected DB');
            shouldReset = true;
        }
        if (this._self.#monitorCallback) {
            console.warn('Returning a client with active MONITOR');
            shouldReset = true;
        }
        if (this._self.#queue.isPubSubActive) {
            console.warn('Returning a client with active PubSub');
            shouldReset = true;
        }
        if (this._self.#dirtyWatch || this._self.#watchEpoch) {
            console.warn('Returning a client with active WATCH');
            shouldReset = true;
        }
        if (shouldReset) {
            return this.reset();
        }
    }
    /**
     * @deprecated use .close instead
     */
    QUIT() {
        this._self.#credentialsSubscription?.dispose();
        this._self.#credentialsSubscription = null;
        return this._self.#socket.quit(async () => {
            clearTimeout(this._self.#pingTimer);
            const quitPromise = this._self.#queue.addCommand(['QUIT']);
            this._self.#scheduleWrite();
            return quitPromise;
        });
    }
    quit = this.QUIT;
    /**
     * @deprecated use .destroy instead
     */
    disconnect() {
        return Promise.resolve(this.destroy());
    }
    /**
     * Close the client. Wait for pending commands.
     */
    close() {
        return new Promise(resolve => {
            clearTimeout(this._self.#pingTimer);
            this._self.#socket.close();
            this._self.#clientSideCache?.onClose();
            if (this._self.#queue.isEmpty()) {
                this._self.#socket.destroySocket();
                return resolve();
            }
            const maybeClose = () => {
                if (!this._self.#queue.isEmpty())
                    return;
                this._self.#socket.off('data', maybeClose);
                this._self.#socket.destroySocket();
                resolve();
            };
            this._self.#socket.on('data', maybeClose);
            this._self.#credentialsSubscription?.dispose();
            this._self.#credentialsSubscription = null;
        });
    }
    /**
     * Destroy the client. Rejects all commands immediately.
     */
    destroy() {
        clearTimeout(this._self.#pingTimer);
        this._self.#queue.flushAll(new errors_1.DisconnectsClientError());
        this._self.#socket.destroy();
        this._self.#clientSideCache?.onClose();
        this._self.#credentialsSubscription?.dispose();
        this._self.#credentialsSubscription = null;
    }
    ref() {
        this._self.#socket.ref();
    }
    unref() {
        this._self.#socket.unref();
    }
}
_a = RedisClient;
exports.default = RedisClient;
//# sourceMappingURL=index.js.map
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
