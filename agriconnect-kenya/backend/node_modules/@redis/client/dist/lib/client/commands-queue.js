"use strict";
<<<<<<< HEAD
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _RedisCommandsQueue_instances, _a, _RedisCommandsQueue_flushQueue, _RedisCommandsQueue_maxLength, _RedisCommandsQueue_waitingToBeSent, _RedisCommandsQueue_waitingForReply, _RedisCommandsQueue_onShardedChannelMoved, _RedisCommandsQueue_pubSub, _RedisCommandsQueue_chainInExecution, _RedisCommandsQueue_decoder, _RedisCommandsQueue_pushPubSubCommand;
Object.defineProperty(exports, "__esModule", { value: true });
const LinkedList = require("yallist");
const errors_1 = require("../errors");
const decoder_1 = require("./RESP2/decoder");
const encoder_1 = require("./RESP2/encoder");
const pub_sub_1 = require("./pub-sub");
const PONG = Buffer.from('pong');
class RedisCommandsQueue {
    get isPubSubActive() {
        return __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").isActive;
    }
    constructor(maxLength, onShardedChannelMoved) {
        _RedisCommandsQueue_instances.add(this);
        _RedisCommandsQueue_maxLength.set(this, void 0);
        _RedisCommandsQueue_waitingToBeSent.set(this, new LinkedList());
        _RedisCommandsQueue_waitingForReply.set(this, new LinkedList());
        _RedisCommandsQueue_onShardedChannelMoved.set(this, void 0);
        _RedisCommandsQueue_pubSub.set(this, new pub_sub_1.PubSub());
        _RedisCommandsQueue_chainInExecution.set(this, void 0);
        _RedisCommandsQueue_decoder.set(this, new decoder_1.default({
            returnStringsAsBuffers: () => {
                return !!__classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").head?.value.returnBuffers ||
                    __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").isActive;
            },
            onReply: reply => {
                if (__classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").isActive && Array.isArray(reply)) {
                    if (__classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").handleMessageReply(reply))
                        return;
                    const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(reply);
                    if (isShardedUnsubscribe && !__classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").length) {
                        const channel = reply[1].toString();
                        __classPrivateFieldGet(this, _RedisCommandsQueue_onShardedChannelMoved, "f").call(this, channel, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").removeShardedListeners(channel));
                        return;
                    }
                    else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(reply)) {
                        const head = __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").head.value;
                        if ((Number.isNaN(head.channelsCounter) && reply[2] === 0) ||
                            --head.channelsCounter === 0) {
                            __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").shift().resolve();
                        }
                        return;
                    }
                    if (PONG.equals(reply[0])) {
                        const { resolve, returnBuffers } = __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").shift(), buffer = (reply[1].length === 0 ? reply[0] : reply[1]);
                        resolve(returnBuffers ? buffer : buffer.toString());
                        return;
                    }
                }
                const { resolve, reject } = __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").shift();
                if (reply instanceof errors_1.ErrorReply) {
                    reject(reply);
                }
                else {
                    resolve(reply);
                }
            }
        }));
        __classPrivateFieldSet(this, _RedisCommandsQueue_maxLength, maxLength, "f");
        __classPrivateFieldSet(this, _RedisCommandsQueue_onShardedChannelMoved, onShardedChannelMoved, "f");
    }
    addCommand(args, options) {
        if (__classPrivateFieldGet(this, _RedisCommandsQueue_maxLength, "f") && __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").length + __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").length >= __classPrivateFieldGet(this, _RedisCommandsQueue_maxLength, "f")) {
            return Promise.reject(new Error('The queue is full'));
        }
        else if (options?.signal?.aborted) {
            return Promise.reject(new errors_1.AbortError());
        }
        return new Promise((resolve, reject) => {
            const node = new LinkedList.Node({
                args,
                chainId: options?.chainId,
                returnBuffers: options?.returnBuffers,
                resolve,
                reject
            });
            if (options?.signal) {
                const listener = () => {
                    __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").removeNode(node);
                    node.value.reject(new errors_1.AbortError());
                };
                node.value.abort = {
                    signal: options.signal,
                    listener
                };
                // AbortSignal type is incorrent
                options.signal.addEventListener('abort', listener, {
                    once: true
                });
            }
            if (options?.asap) {
                __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").unshiftNode(node);
            }
            else {
                __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").pushNode(node);
            }
        });
    }
    subscribe(type, channels, listener, returnBuffers) {
        return __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").subscribe(type, channels, listener, returnBuffers));
    }
    unsubscribe(type, channels, listener, returnBuffers) {
        return __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").unsubscribe(type, channels, listener, returnBuffers));
    }
    resubscribe() {
        const commands = __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").resubscribe();
        if (!commands.length)
            return;
        return Promise.all(commands.map(command => __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, command)));
    }
    extendPubSubChannelListeners(type, channel, listeners) {
        return __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").extendChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
        return __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").extendTypeListeners(type, listeners));
    }
    getPubSubListeners(type) {
        return __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").getTypeListeners(type);
    }
    getCommandToSend() {
        const toSend = __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").shift();
        if (!toSend)
            return;
        let encoded;
        try {
            encoded = (0, encoder_1.default)(toSend.args);
        }
        catch (err) {
            toSend.reject(err);
            return;
        }
        __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").push({
            resolve: toSend.resolve,
            reject: toSend.reject,
            channelsCounter: toSend.channelsCounter,
            returnBuffers: toSend.returnBuffers
        });
        __classPrivateFieldSet(this, _RedisCommandsQueue_chainInExecution, toSend.chainId, "f");
        return encoded;
    }
    onReplyChunk(chunk) {
        __classPrivateFieldGet(this, _RedisCommandsQueue_decoder, "f").write(chunk);
    }
    flushWaitingForReply(err) {
        __classPrivateFieldGet(this, _RedisCommandsQueue_decoder, "f").reset();
        __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").reset();
        __classPrivateFieldGet(_a, _a, "m", _RedisCommandsQueue_flushQueue).call(_a, __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f"), err);
        if (!__classPrivateFieldGet(this, _RedisCommandsQueue_chainInExecution, "f"))
            return;
        while (__classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").head?.value.chainId === __classPrivateFieldGet(this, _RedisCommandsQueue_chainInExecution, "f")) {
            __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").shift();
        }
        __classPrivateFieldSet(this, _RedisCommandsQueue_chainInExecution, undefined, "f");
    }
    flushAll(err) {
        __classPrivateFieldGet(this, _RedisCommandsQueue_decoder, "f").reset();
        __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").reset();
        __classPrivateFieldGet(_a, _a, "m", _RedisCommandsQueue_flushQueue).call(_a, __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f"), err);
        __classPrivateFieldGet(_a, _a, "m", _RedisCommandsQueue_flushQueue).call(_a, __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f"), err);
    }
}
_a = RedisCommandsQueue, _RedisCommandsQueue_maxLength = new WeakMap(), _RedisCommandsQueue_waitingToBeSent = new WeakMap(), _RedisCommandsQueue_waitingForReply = new WeakMap(), _RedisCommandsQueue_onShardedChannelMoved = new WeakMap(), _RedisCommandsQueue_pubSub = new WeakMap(), _RedisCommandsQueue_chainInExecution = new WeakMap(), _RedisCommandsQueue_decoder = new WeakMap(), _RedisCommandsQueue_instances = new WeakSet(), _RedisCommandsQueue_flushQueue = function _RedisCommandsQueue_flushQueue(queue, err) {
    while (queue.length) {
        queue.shift().reject(err);
    }
}, _RedisCommandsQueue_pushPubSubCommand = function _RedisCommandsQueue_pushPubSubCommand(command) {
    if (command === undefined)
        return;
    return new Promise((resolve, reject) => {
        __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").push({
            args: command.args,
            channelsCounter: command.channelsCounter,
            returnBuffers: true,
            resolve: () => {
                command.resolve();
                resolve();
            },
            reject: err => {
                command.reject?.();
                reject(err);
            }
        });
    });
};
exports.default = RedisCommandsQueue;
=======
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const linked_list_1 = require("./linked-list");
const encoder_1 = __importDefault(require("../RESP/encoder"));
const decoder_1 = require("../RESP/decoder");
const pub_sub_1 = require("./pub-sub");
const errors_1 = require("../errors");
const enterprise_maintenance_manager_1 = require("./enterprise-maintenance-manager");
const PONG = Buffer.from('pong'), RESET = Buffer.from('RESET');
const RESP2_PUSH_TYPE_MAPPING = {
    ...decoder_1.PUSH_TYPE_MAPPING,
    [decoder_1.RESP_TYPES.SIMPLE_STRING]: Buffer
};
class RedisCommandsQueue {
    #respVersion;
    #maxLength;
    #toWrite = new linked_list_1.DoublyLinkedList();
    #waitingForReply = new linked_list_1.EmptyAwareSinglyLinkedList();
    #onShardedChannelMoved;
    #chainInExecution;
    decoder;
    #pubSub = new pub_sub_1.PubSub();
    #pushHandlers = [this.#onPush.bind(this)];
    #maintenanceCommandTimeout;
    setMaintenanceCommandTimeout(ms) {
        // Prevent possible api misuse
        if (this.#maintenanceCommandTimeout === ms) {
            (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Queue already set maintenanceCommandTimeout to ${ms}, skipping`);
            return;
        }
        ;
        (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Setting maintenance command timeout to ${ms}`);
        this.#maintenanceCommandTimeout = ms;
        if (this.#maintenanceCommandTimeout === undefined) {
            (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Queue will keep maintenanceCommandTimeout for exisitng commands, just to be on the safe side. New commands will receive normal timeouts`);
            return;
        }
        let counter = 0;
        const total = this.#toWrite.length;
        // Overwrite timeouts of all eligible toWrite commands
        for (const node of this.#toWrite.nodes()) {
            const command = node.value;
            // Remove timeout listener if it exists
            RedisCommandsQueue.#removeTimeoutListener(command);
            counter++;
            const newTimeout = this.#maintenanceCommandTimeout;
            // Overwrite the command's timeout
            const signal = AbortSignal.timeout(newTimeout);
            command.timeout = {
                signal,
                listener: () => {
                    this.#toWrite.remove(node);
                    command.reject(new errors_1.CommandTimeoutDuringMaintenanceError(newTimeout));
                },
                originalTimeout: command.timeout?.originalTimeout
            };
            signal.addEventListener('abort', command.timeout.listener, { once: true });
        }
        ;
        (0, enterprise_maintenance_manager_1.dbgMaintenance)(`Total of ${counter} of ${total} timeouts reset to ${ms}`);
    }
    get isPubSubActive() {
        return this.#pubSub.isActive;
    }
    constructor(respVersion, maxLength, onShardedChannelMoved) {
        this.#respVersion = respVersion;
        this.#maxLength = maxLength;
        this.#onShardedChannelMoved = onShardedChannelMoved;
        this.decoder = this.#initiateDecoder();
    }
    #onReply(reply) {
        this.#waitingForReply.shift().resolve(reply);
    }
    #onErrorReply(err) {
        this.#waitingForReply.shift().reject(err);
    }
    #onPush(push) {
        // TODO: type
        if (this.#pubSub.handleMessageReply(push))
            return true;
        const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(push);
        if (isShardedUnsubscribe && !this.#waitingForReply.length) {
            const channel = push[1].toString();
            this.#onShardedChannelMoved(channel, this.#pubSub.removeShardedListeners(channel));
            return true;
        }
        else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(push)) {
            const head = this.#waitingForReply.head.value;
            if ((Number.isNaN(head.channelsCounter) && push[2] === 0) ||
                --head.channelsCounter === 0) {
                this.#waitingForReply.shift().resolve();
            }
            return true;
        }
        return false;
    }
    #getTypeMapping() {
        return this.#waitingForReply.head.value.typeMapping ?? {};
    }
    #initiateDecoder() {
        return new decoder_1.Decoder({
            onReply: reply => this.#onReply(reply),
            onErrorReply: err => this.#onErrorReply(err),
            //TODO: we can shave off a few cycles by not adding onPush handler at all if CSC is not used
            onPush: push => {
                for (const pushHandler of this.#pushHandlers) {
                    if (pushHandler(push))
                        return;
                }
            },
            getTypeMapping: () => this.#getTypeMapping()
        });
    }
    addPushHandler(handler) {
        this.#pushHandlers.push(handler);
    }
    async waitForInflightCommandsToComplete() {
        // In-flight commands already completed
        if (this.#waitingForReply.length === 0) {
            return;
        }
        ;
        // Otherwise wait for in-flight commands to fire `empty` event
        return new Promise(resolve => {
            this.#waitingForReply.events.on('empty', resolve);
        });
    }
    addCommand(args, options) {
        if (this.#maxLength && this.#toWrite.length + this.#waitingForReply.length >= this.#maxLength) {
            return Promise.reject(new Error('The queue is full'));
        }
        else if (options?.abortSignal?.aborted) {
            return Promise.reject(new errors_1.AbortError());
        }
        return new Promise((resolve, reject) => {
            let node;
            const value = {
                args,
                chainId: options?.chainId,
                abort: undefined,
                timeout: undefined,
                resolve,
                reject,
                channelsCounter: undefined,
                typeMapping: options?.typeMapping
            };
            // If #maintenanceCommandTimeout was explicitly set, we should
            // use it instead of the timeout provided by the command
            const timeout = this.#maintenanceCommandTimeout ?? options?.timeout;
            const wasInMaintenance = this.#maintenanceCommandTimeout !== undefined;
            if (timeout) {
                const signal = AbortSignal.timeout(timeout);
                value.timeout = {
                    signal,
                    listener: () => {
                        this.#toWrite.remove(node);
                        value.reject(wasInMaintenance ? new errors_1.CommandTimeoutDuringMaintenanceError(timeout) : new errors_1.TimeoutError());
                    },
                    originalTimeout: options?.timeout
                };
                signal.addEventListener('abort', value.timeout.listener, { once: true });
            }
            const signal = options?.abortSignal;
            if (signal) {
                value.abort = {
                    signal,
                    listener: () => {
                        this.#toWrite.remove(node);
                        value.reject(new errors_1.AbortError());
                    }
                };
                signal.addEventListener('abort', value.abort.listener, { once: true });
            }
            node = this.#toWrite.add(value, options?.asap);
        });
    }
    #addPubSubCommand(command, asap = false, chainId) {
        return new Promise((resolve, reject) => {
            this.#toWrite.add({
                args: command.args,
                chainId,
                abort: undefined,
                timeout: undefined,
                resolve() {
                    command.resolve();
                    resolve();
                },
                reject(err) {
                    command.reject?.();
                    reject(err);
                },
                channelsCounter: command.channelsCounter,
                typeMapping: decoder_1.PUSH_TYPE_MAPPING
            }, asap);
        });
    }
    #setupPubSubHandler() {
        // RESP3 uses `onPush` to handle PubSub, so no need to modify `onReply`
        if (this.#respVersion !== 2)
            return;
        this.decoder.onReply = (reply => {
            if (Array.isArray(reply)) {
                if (this.#onPush(reply))
                    return;
                if (PONG.equals(reply[0])) {
                    const { resolve, typeMapping } = this.#waitingForReply.shift(), buffer = (reply[1].length === 0 ? reply[0] : reply[1]);
                    resolve(typeMapping?.[decoder_1.RESP_TYPES.SIMPLE_STRING] === Buffer ? buffer : buffer.toString());
                    return;
                }
            }
            return this.#onReply(reply);
        });
        this.decoder.getTypeMapping = () => RESP2_PUSH_TYPE_MAPPING;
    }
    subscribe(type, channels, listener, returnBuffers) {
        const command = this.#pubSub.subscribe(type, channels, listener, returnBuffers);
        if (!command)
            return;
        this.#setupPubSubHandler();
        return this.#addPubSubCommand(command);
    }
    #resetDecoderCallbacks() {
        this.decoder.onReply = (reply => this.#onReply(reply));
        this.decoder.getTypeMapping = () => this.#getTypeMapping();
    }
    unsubscribe(type, channels, listener, returnBuffers) {
        const command = this.#pubSub.unsubscribe(type, channels, listener, returnBuffers);
        if (!command)
            return;
        if (command && this.#respVersion === 2) {
            // RESP2 modifies `onReply` to handle PubSub (see #setupPubSubHandler)
            const { resolve } = command;
            command.resolve = () => {
                if (!this.#pubSub.isActive) {
                    this.#resetDecoderCallbacks();
                }
                resolve();
            };
        }
        return this.#addPubSubCommand(command);
    }
    removeAllPubSubListeners() {
        return this.#pubSub.removeAllListeners();
    }
    resubscribe(chainId) {
        const commands = this.#pubSub.resubscribe();
        if (!commands.length)
            return;
        this.#setupPubSubHandler();
        return Promise.all(commands.map(command => this.#addPubSubCommand(command, true, chainId)));
    }
    extendPubSubChannelListeners(type, channel, listeners) {
        const command = this.#pubSub.extendChannelListeners(type, channel, listeners);
        if (!command)
            return;
        this.#setupPubSubHandler();
        return this.#addPubSubCommand(command);
    }
    extendPubSubListeners(type, listeners) {
        const command = this.#pubSub.extendTypeListeners(type, listeners);
        if (!command)
            return;
        this.#setupPubSubHandler();
        return this.#addPubSubCommand(command);
    }
    getPubSubListeners(type) {
        return this.#pubSub.listeners[type];
    }
    monitor(callback, options) {
        return new Promise((resolve, reject) => {
            const typeMapping = options?.typeMapping ?? {};
            this.#toWrite.add({
                args: ['MONITOR'],
                chainId: options?.chainId,
                abort: undefined,
                timeout: undefined,
                // using `resolve` instead of using `.then`/`await` to make sure it'll be called before processing the next reply
                resolve: () => {
                    // after running `MONITOR` only `MONITOR` and `RESET` replies are expected
                    // any other command should cause an error
                    // if `RESET` already overrides `onReply`, set monitor as it's fallback
                    if (this.#resetFallbackOnReply) {
                        this.#resetFallbackOnReply = callback;
                    }
                    else {
                        this.decoder.onReply = callback;
                    }
                    this.decoder.getTypeMapping = () => typeMapping;
                    resolve();
                },
                reject,
                channelsCounter: undefined,
                typeMapping
            }, options?.asap);
        });
    }
    resetDecoder() {
        this.#resetDecoderCallbacks();
        this.decoder.reset();
    }
    #resetFallbackOnReply;
    async reset(chainId, typeMapping) {
        return new Promise((resolve, reject) => {
            // overriding onReply to handle `RESET` while in `MONITOR` or PubSub mode
            this.#resetFallbackOnReply = this.decoder.onReply;
            this.decoder.onReply = (reply => {
                if ((typeof reply === 'string' && reply === 'RESET') ||
                    (reply instanceof Buffer && RESET.equals(reply))) {
                    this.#resetDecoderCallbacks();
                    this.#resetFallbackOnReply = undefined;
                    this.#pubSub.reset();
                    this.#waitingForReply.shift().resolve(reply);
                    return;
                }
                this.#resetFallbackOnReply(reply);
            });
            this.#toWrite.push({
                args: ['RESET'],
                chainId,
                abort: undefined,
                timeout: undefined,
                resolve,
                reject,
                channelsCounter: undefined,
                typeMapping
            });
        });
    }
    isWaitingToWrite() {
        return this.#toWrite.length > 0;
    }
    *commandsToWrite() {
        let toSend = this.#toWrite.shift();
        while (toSend) {
            let encoded;
            try {
                encoded = (0, encoder_1.default)(toSend.args);
            }
            catch (err) {
                toSend.reject(err);
                toSend = this.#toWrite.shift();
                continue;
            }
            // TODO reuse `toSend` or create new object?
            toSend.args = undefined;
            if (toSend.abort) {
                RedisCommandsQueue.#removeAbortListener(toSend);
                toSend.abort = undefined;
            }
            if (toSend.timeout) {
                RedisCommandsQueue.#removeTimeoutListener(toSend);
                toSend.timeout = undefined;
            }
            this.#chainInExecution = toSend.chainId;
            toSend.chainId = undefined;
            this.#waitingForReply.push(toSend);
            yield encoded;
            toSend = this.#toWrite.shift();
        }
    }
    #flushWaitingForReply(err) {
        for (const node of this.#waitingForReply) {
            node.reject(err);
        }
        this.#waitingForReply.reset();
    }
    static #removeAbortListener(command) {
        command.abort.signal.removeEventListener('abort', command.abort.listener);
    }
    static #removeTimeoutListener(command) {
        command.timeout?.signal.removeEventListener('abort', command.timeout.listener);
    }
    static #flushToWrite(toBeSent, err) {
        if (toBeSent.abort) {
            RedisCommandsQueue.#removeAbortListener(toBeSent);
        }
        if (toBeSent.timeout) {
            RedisCommandsQueue.#removeTimeoutListener(toBeSent);
        }
        toBeSent.reject(err);
    }
    flushWaitingForReply(err) {
        this.resetDecoder();
        this.#pubSub.reset();
        this.#flushWaitingForReply(err);
        if (!this.#chainInExecution)
            return;
        while (this.#toWrite.head?.value.chainId === this.#chainInExecution) {
            RedisCommandsQueue.#flushToWrite(this.#toWrite.shift(), err);
        }
        this.#chainInExecution = undefined;
    }
    flushAll(err) {
        this.resetDecoder();
        this.#pubSub.reset();
        this.#flushWaitingForReply(err);
        for (const node of this.#toWrite) {
            RedisCommandsQueue.#flushToWrite(node, err);
        }
        this.#toWrite.reset();
    }
    isEmpty() {
        return (this.#toWrite.length === 0 &&
            this.#waitingForReply.length === 0);
    }
}
exports.default = RedisCommandsQueue;
//# sourceMappingURL=commands-queue.js.map
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
