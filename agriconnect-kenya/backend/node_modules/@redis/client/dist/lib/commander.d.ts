<<<<<<< HEAD
import { ClientCommandOptions } from './client';
import { CommandOptions } from './command-options';
import { RedisCommand, RedisCommandArgument, RedisCommandArguments, RedisCommandReply, RedisFunction, RedisFunctions, RedisModules, RedisScript, RedisScripts } from './commands';
type Instantiable<T = any> = new (...args: Array<any>) => T;
type CommandsExecutor<C extends RedisCommand = RedisCommand> = (command: C, args: Array<unknown>, name: string) => unknown;
interface AttachCommandsConfig<C extends RedisCommand> {
    BaseClass: Instantiable;
    commands: Record<string, C>;
    executor: CommandsExecutor<C>;
}
export declare function attachCommands<C extends RedisCommand>({ BaseClass, commands, executor }: AttachCommandsConfig<C>): void;
interface AttachExtensionsConfig<T extends Instantiable = Instantiable> {
    BaseClass: T;
    modulesExecutor: CommandsExecutor;
    modules?: RedisModules;
    functionsExecutor: CommandsExecutor<RedisFunction>;
    functions?: RedisFunctions;
    scriptsExecutor: CommandsExecutor<RedisScript>;
    scripts?: RedisScripts;
}
export declare function attachExtensions(config: AttachExtensionsConfig): any;
export declare function transformCommandArguments<T = ClientCommandOptions>(command: RedisCommand, args: Array<unknown>): {
    jsArgs: Array<unknown>;
    args: RedisCommandArguments;
    options: CommandOptions<T> | undefined;
};
export declare function transformLegacyCommandArguments(args: Array<any>): Array<any>;
export declare function transformCommandReply<C extends RedisCommand>(command: C, rawReply: unknown, preserved: unknown): RedisCommandReply<C>;
export declare function fCallArguments(name: RedisCommandArgument, fn: RedisFunction, args: RedisCommandArguments): RedisCommandArguments;
export {};
=======
/// <reference types="node" />
import { Command, CommanderConfig, RedisArgument, RedisCommands, RedisFunction, RedisFunctions, RedisModules, RedisScript, RedisScripts, RespVersions, TransformReply } from './RESP/types';
interface AttachConfigOptions<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions> {
    BaseClass: new (...args: any) => any;
    commands: RedisCommands;
    createCommand(command: Command, resp: RespVersions): (...args: any) => any;
    createModuleCommand(command: Command, resp: RespVersions): (...args: any) => any;
    createFunctionCommand(name: string, fn: RedisFunction, resp: RespVersions): (...args: any) => any;
    createScriptCommand(script: RedisScript, resp: RespVersions): (...args: any) => any;
    config?: CommanderConfig<M, F, S, RESP>;
}
export declare function attachConfig<M extends RedisModules, F extends RedisFunctions, S extends RedisScripts, RESP extends RespVersions>({ BaseClass, commands, createCommand, createModuleCommand, createFunctionCommand, createScriptCommand, config }: AttachConfigOptions<M, F, S, RESP>): any;
export declare function getTransformReply(command: Command, resp: RespVersions): TransformReply | undefined;
export declare function functionArgumentsPrefix(name: string, fn: RedisFunction): RedisArgument[];
export declare function scriptArgumentsPrefix(script: RedisScript): (string | Buffer)[];
export {};
//# sourceMappingURL=commander.d.ts.map
>>>>>>> 5e3222a0 (Initial commit for Agriconnect Kenya project)
